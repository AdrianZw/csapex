<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>STANN: bruteNN&lt; Point &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>bruteNN&lt; Point &gt; Class Template Reference</h1><!-- doxytag: class="bruteNN" -->
<p>A Brute force NN search class This class is a simple brute force algorithm for computing nearest neighbors. It is very innefficient and should be used only for accuracy tests.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bruteNN_8hpp_source.html">bruteNN.hpp</a>&gt;</code></p>

<p><a href="classbruteNN-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbruteNN.html#a1f097c7e26ddd7fe0f2076f0c9f66fba">bruteNN</a> (Point *points, long int N)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor Constructs a brute force nearest neighbor search structure out of the given data points.  <a href="#a1f097c7e26ddd7fe0f2076f0c9f66fba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a9d187cb0554f1b3f63751224e00320"></a><!-- doxytag: member="bruteNN::~bruteNN" ref="a2a9d187cb0554f1b3f63751224e00320" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbruteNN.html#a2a9d187cb0554f1b3f63751224e00320">~bruteNN</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbruteNN.html#a8cd12577267f498dc8374079ea9abdf3">ksearch</a> (Point q, int k, std::vector&lt; long unsigned int &gt; &amp;nn_idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nearest neighbor search function.  <a href="#a8cd12577267f498dc8374079ea9abdf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbruteNN.html#a47d29c0fff58542dd25e6e67c149c017">ksearch</a> (Point q, int k, std::vector&lt; long unsigned int &gt; &amp;nn_idx, std::vector&lt; double &gt; &amp;d_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nearest neighbor search function.  <a href="#a47d29c0fff58542dd25e6e67c149c017"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Point&gt;<br/>
 class bruteNN&lt; Point &gt;</h3>

<p>A Brute force NN search class This class is a simple brute force algorithm for computing nearest neighbors. It is very innefficient and should be used only for accuracy tests. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1f097c7e26ddd7fe0f2076f0c9f66fba"></a><!-- doxytag: member="bruteNN::bruteNN" ref="a1f097c7e26ddd7fe0f2076f0c9f66fba" args="(Point *points, long int N)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbruteNN.html">bruteNN</a>&lt; Point &gt;::<a class="el" href="classbruteNN.html">bruteNN</a> </td>
          <td>(</td>
          <td class="paramtype">Point *&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&nbsp;</td>
          <td class="paramname"> <em>N</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor Constructs a brute force nearest neighbor search structure out of the given data points. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*points</em>&nbsp;</td><td>Pointer to list of input points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>number of input points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a47d29c0fff58542dd25e6e67c149c017"></a><!-- doxytag: member="bruteNN::ksearch" ref="a47d29c0fff58542dd25e6e67c149c017" args="(Point q, int k, std::vector&lt; long unsigned int &gt; &amp;nn_idx, std::vector&lt; double &gt; &amp;d_index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbruteNN.html">bruteNN</a>&lt; Point &gt;::ksearch </td>
          <td>(</td>
          <td class="paramtype">Point&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long unsigned int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nn_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>d_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Nearest neighbor search function. </p>
<p>This function returns the nearest k neighbors from the data structure to the given query point, as well as the squared distance to the query point. The return vector contains the indexes to the answer points in the original data array passed at construction time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>Query point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>number of neighbors to search for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nn_idx</em>&nbsp;</td><td>Vector in which answer is written </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d_index</em>&nbsp;</td><td>Vector in which square distances are written </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="qknn_8hpp_source.html#l00136">qknn::answer()</a>, and <a class="el" href="qknn_8hpp_source.html#l00113">qknn::update()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cd12577267f498dc8374079ea9abdf3"></a><!-- doxytag: member="bruteNN::ksearch" ref="a8cd12577267f498dc8374079ea9abdf3" args="(Point q, int k, std::vector&lt; long unsigned int &gt; &amp;nn_idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbruteNN.html">bruteNN</a>&lt; Point &gt;::ksearch </td>
          <td>(</td>
          <td class="paramtype">Point&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long unsigned int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nn_idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Nearest neighbor search function. </p>
<p>This function returns the nearest k neighbors from the data structure to the given query point. The return vector contains the indexes to the answer points in the original data array passed at construction time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>Query point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>number of neighbors to search for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nn_idx</em>&nbsp;</td><td>Vector in which answer is written </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="qknn_8hpp_source.html#l00136">qknn::answer()</a>, <a class="el" href="qknn_8hpp_source.html#l00088">qknn::set_size()</a>, and <a class="el" href="qknn_8hpp_source.html#l00113">qknn::update()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bruteNN_8hpp_source.html">bruteNN.hpp</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Apr 6 18:56:35 2010 for STANN by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
